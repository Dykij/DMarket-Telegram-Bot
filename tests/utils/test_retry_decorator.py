"""Tests for retry_decorator module."""

from unittest.mock import AsyncMock

import pytest

from src.utils.exceptions import NetworkError, RateLimitError
from src.utils.retry_decorator import retry_api_call, retry_on_failure


class TestRetryOnFailure:
    """Tests for retry_on_failure decorator."""

    @pytest.mark.asyncio()
    async def test_async_function_succeeds_first_try(self):
        """Test that successful async function doesn't retry."""
        # Arrange
        mock_func = AsyncMock(return_value="success")

        # Decorate function
        @retry_on_failure(max_attempts=3)
        async def test_func():
            return await mock_func()

        # Act
        result = await test_func()

        # Assert
        assert result == "success"
        assert mock_func.call_count == 1

    @pytest.mark.asyncio()
    async def test_async_function_retries_on_network_error(self):
        """Test that async function retries on NetworkError."""
        # Arrange
        mock_func = AsyncMock(side_effect=[NetworkError("Connection failed"), "success"])

        @retry_on_failure(max_attempts=3, min_wait=0.1, max_wait=0.2)
        async def test_func():
            result = await mock_func()
            if isinstance(result, str):
                return result
            raise result

        # Act
        result = await test_func()

        # Assert
        assert result == "success"
        assert mock_func.call_count == 2

    @pytest.mark.asyncio()
    async def test_async_function_exhausts_retries(self):
        """Test that async function raises after max retries."""
        # Arrange
        mock_func = AsyncMock(side_effect=NetworkError("Persistent failure"))

        @retry_on_failure(max_attempts=3, min_wait=0.1, max_wait=0.2)
        async def test_func():
            await mock_func()

        # Act & Assert
        with pytest.raises(NetworkError):
            await test_func()

        assert mock_func.call_count == 3

    @pytest.mark.asyncio()
    async def test_async_function_does_not_retry_on_unexpected_error(self):
        """Test that async function doesn't retry on non-retryable errors."""
        # Arrange
        mock_func = AsyncMock(side_effect=ValueError("Invalid value"))

        @retry_on_failure(
            max_attempts=3,
            min_wait=0.1,
            retry_on=(NetworkError, ConnectionError),
        )
        async def test_func():
            await mock_func()

        # Act & Assert
        with pytest.raises(ValueError):
            await test_func()

        assert mock_func.call_count == 1

    @pytest.mark.asyncio()
    async def test_retry_with_custom_exceptions(self):
        """Test retry with custom exception types."""
        # Arrange
        call_count = 0

        @retry_on_failure(
            max_attempts=3,
            min_wait=0.1,
            max_wait=0.2,
            retry_on=(RateLimitError,),
        )
        async def test_func():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise RateLimitError("Rate limit exceeded")
            return "success"

        # Act
        result = await test_func()

        # Assert
        assert result == "success"
        assert call_count == 2

    @pytest.mark.asyncio()
    async def test_exponential_backoff_timing(self):
        """Test that exponential backoff increases wait time."""
        # Arrange
        call_times = []

        @retry_on_failure(
            max_attempts=3,
            min_wait=0.1,
            max_wait=0.5,
            multiplier=2,
        )
        async def test_func():
            import time

            call_times.append(time.time())
            if len(call_times) < 2:
                raise NetworkError("Temporary failure")
            return "success"

        # Act
        result = await test_func()

        # Assert
        assert result == "success"
        assert len(call_times) == 2
        # Check that there was a delay between calls (at least 0.09s to account for timing)
        time_diff = call_times[1] - call_times[0]
        assert time_diff >= 0.09


class TestRetryApiCall:
    """Tests for retry_api_call decorator."""

    @pytest.mark.asyncio()
    async def test_retries_on_network_error(self):
        """Test that API call retries on NetworkError."""
        # Arrange
        call_count = 0

        @retry_api_call(max_attempts=3, min_wait=0.1, max_wait=0.2)
        async def api_call():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise NetworkError("Network issue")
            return {"data": "success"}

        # Act
        result = await api_call()

        # Assert
        assert result == {"data": "success"}
        assert call_count == 2

    @pytest.mark.asyncio()
    async def test_retries_on_rate_limit_error(self):
        """Test that API call retries on RateLimitError."""
        # Arrange
        call_count = 0

        @retry_api_call(max_attempts=3, min_wait=0.1, max_wait=0.2)
        async def api_call():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise RateLimitError("Too many requests")
            return {"data": "success"}

        # Act
        result = await api_call()

        # Assert
        assert result == {"data": "success"}
        assert call_count == 2

    @pytest.mark.asyncio()
    async def test_retries_on_timeout_error(self):
        """Test that API call retries on TimeoutError."""
        # Arrange
        call_count = 0

        @retry_api_call(max_attempts=3, min_wait=0.1, max_wait=0.2)
        async def api_call():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise TimeoutError("Request timeout")
            return {"data": "success"}

        # Act
        result = await api_call()

        # Assert
        assert result == {"data": "success"}
        assert call_count == 2

    @pytest.mark.asyncio()
    async def test_does_not_retry_on_other_errors(self):
        """Test that API call doesn't retry on non-retryable errors."""
        # Arrange
        call_count = 0

        @retry_api_call(max_attempts=3)
        async def api_call():
            nonlocal call_count
            call_count += 1
            raise ValueError("Invalid data")

        # Act & Assert
        with pytest.raises(ValueError):
            await api_call()

        assert call_count == 1

    @pytest.mark.asyncio()
    async def test_logging_on_retry(self, caplog):
        """Test that retries are logged."""
        # Arrange
        call_count = 0

        @retry_api_call(max_attempts=2, min_wait=0.1, max_wait=0.2)
        async def api_call():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise NetworkError("Network error")
            return "success"

        # Act
        with caplog.at_level("WARNING"):
            result = await api_call()

        # Assert
        assert result == "success"
        assert "Retry attempt" in caplog.text
