"""–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø–æ–ª–Ω—ã–π workflow —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:
- –°–æ–∑–¥–∞–Ω–∏–µ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
- –û—á–µ—Ä–µ–¥—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
- –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏ throttling
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram
"""

from datetime import datetime
from unittest.mock import AsyncMock, MagicMock

import pytest


# ============================================================================
# FIXTURES
# ============================================================================


@pytest.fixture()
def mock_bot():
    """Create mock Telegram bot."""
    bot = AsyncMock()
    bot.send_message = AsyncMock(return_value=MagicMock(message_id=123))
    return bot


@pytest.fixture()
def mock_user_settings():
    """Create mock user notification settings."""
    return {
        "user_id": 123456789,
        "enabled": True,
        "quiet_hours": {"start": 23, "end": 7},
        "max_alerts_per_day": 50,
        "min_interval": 300,  # 5 minutes
        "notification_types": {
            "price_drop": True,
            "price_rise": True,
            "arbitrage": True,
            "good_deal": True,
        },
    }


@pytest.fixture()
def sample_notifications():
    """Create sample notifications."""
    return [
        {
            "type": "price_drop",
            "item": "AK-47 | Redline",
            "old_price": 20.00,
            "new_price": 15.00,
            "change_percent": -25.0,
            "timestamp": datetime.now().isoformat(),
        },
        {
            "type": "arbitrage",
            "item": "AWP | Dragon Lore",
            "buy_price": 1500.00,
            "sell_price": 1800.00,
            "profit": 300.00,
            "profit_percent": 20.0,
            "timestamp": datetime.now().isoformat(),
        },
        {
            "type": "good_deal",
            "item": "M4A4 | Howl",
            "price": 800.00,
            "market_average": 1000.00,
            "discount_percent": 20.0,
            "timestamp": datetime.now().isoformat(),
        },
    ]


# ============================================================================
# NOTIFICATION QUEUE TESTS
# ============================================================================


class TestNotificationQueueIntegration:
    """Tests for notification queue integration."""

    @pytest.mark.asyncio()
    async def test_queue_creation(self, mock_bot):
        """Test notification queue creation."""
        from src.telegram_bot.notification_queue import NotificationQueue

        queue = NotificationQueue(bot=mock_bot)

        assert queue is not None
        assert queue.bot is mock_bot
        assert not queue.is_running

    @pytest.mark.asyncio()
    async def test_queue_enqueue_method_exists(self, mock_bot):
        """Test queue has enqueue method."""
        from src.telegram_bot.notification_queue import NotificationQueue

        queue = NotificationQueue(bot=mock_bot)

        assert hasattr(queue, "enqueue")

    @pytest.mark.asyncio()
    async def test_queue_start_stop(self, mock_bot):
        """Test queue start and stop."""
        from src.telegram_bot.notification_queue import NotificationQueue

        queue = NotificationQueue(bot=mock_bot)

        # Start should work
        await queue.start()
        assert queue.is_running

        # Stop should work
        await queue.stop()
        assert not queue.is_running


# ============================================================================
# NOTIFICATION FILTERING TESTS
# ============================================================================


class TestNotificationFilteringIntegration:
    """Tests for notification filtering integration."""

    @pytest.mark.asyncio()
    async def test_filters_disabled_notification_types(
        self, mock_bot, mock_user_settings, sample_notifications
    ):
        """Test filtering disabled notification types."""
        # Disable price_rise notifications
        mock_user_settings["notification_types"]["price_rise"] = False

        notification = {
            "type": "price_rise",
            "item": "Test Item",
            "old_price": 10.00,
            "new_price": 15.00,
        }

        # Should be filtered out
        enabled = mock_user_settings["notification_types"].get("price_rise", True)
        assert enabled is False

    @pytest.mark.asyncio()
    async def test_filters_during_quiet_hours(self, mock_user_settings):
        """Test filtering during quiet hours."""
        current_hour = datetime.now().hour

        # Set quiet hours to include current hour
        mock_user_settings["quiet_hours"] = {
            "start": current_hour,
            "end": (current_hour + 1) % 24,
        }

        # Check if current hour is in quiet hours
        start = mock_user_settings["quiet_hours"]["start"]
        end = mock_user_settings["quiet_hours"]["end"]

        if start <= end:
            is_quiet = start <= current_hour < end
        else:
            is_quiet = current_hour >= start or current_hour < end

        # During quiet hours, notifications should be filtered
        if is_quiet:
            assert True  # Would filter

    @pytest.mark.asyncio()
    async def test_respects_daily_limit(self, mock_user_settings):
        """Test respecting daily notification limit."""
        mock_user_settings["max_alerts_per_day"] = 5
        mock_user_settings["daily_count"] = 5

        # Already at limit
        at_limit = mock_user_settings["daily_count"] >= mock_user_settings["max_alerts_per_day"]
        assert at_limit is True


# ============================================================================
# NOTIFICATION FORMATTING TESTS
# ============================================================================


class TestNotificationFormattingIntegration:
    """Tests for notification formatting integration."""

    @pytest.mark.asyncio()
    async def test_format_price_drop_notification(self, sample_notifications):
        """Test formatting price drop notification."""
        notification = sample_notifications[0]  # price_drop

        # Format message
        message = "üìâ –ü–∞–¥–µ–Ω–∏–µ —Ü–µ–Ω—ã!\n"
        message += f"üéÆ {notification['item']}\n"
        message += f"üí∞ ${notification['old_price']:.2f} ‚Üí ${notification['new_price']:.2f}\n"
        message += f"üìä –ò–∑–º–µ–Ω–µ–Ω–∏–µ: {notification['change_percent']:.1f}%"

        assert "üìâ" in message
        assert notification["item"] in message
        assert f"{notification['old_price']:.2f}" in message

    @pytest.mark.asyncio()
    async def test_format_arbitrage_notification(self, sample_notifications):
        """Test formatting arbitrage notification."""
        notification = sample_notifications[1]  # arbitrage

        # Format message
        message = "üí∞ –ê—Ä–±–∏—Ç—Ä–∞–∂ –Ω–∞–π–¥–µ–Ω!\n"
        message += f"üéÆ {notification['item']}\n"
        message += f"üìä –ü–æ–∫—É–ø–∫–∞: ${notification['buy_price']:.2f}\n"
        message += f"üìà –ü—Ä–æ–¥–∞–∂–∞: ${notification['sell_price']:.2f}\n"
        message += (
            f"üíµ –ü—Ä–∏–±—ã–ª—å: ${notification['profit']:.2f} ({notification['profit_percent']:.1f}%)"
        )

        assert "üí∞" in message
        assert notification["item"] in message
        assert f"{notification['profit']:.2f}" in message

    @pytest.mark.asyncio()
    async def test_format_good_deal_notification(self, sample_notifications):
        """Test formatting good deal notification."""
        notification = sample_notifications[2]  # good_deal

        # Format message
        message = "üî• –í—ã–≥–æ–¥–Ω–∞—è —Å–¥–µ–ª–∫–∞!\n"
        message += f"üéÆ {notification['item']}\n"
        message += f"üí∞ –¶–µ–Ω–∞: ${notification['price']:.2f}\n"
        message += f"üìä –°—Ä–µ–¥–Ω—è—è: ${notification['market_average']:.2f}\n"
        message += f"üè∑Ô∏è –°–∫–∏–¥–∫–∞: {notification['discount_percent']:.1f}%"

        assert "üî•" in message
        assert notification["item"] in message
        assert f"{notification['discount_percent']:.1f}%" in message


# ============================================================================
# NOTIFICATION DELIVERY TESTS
# ============================================================================


class TestNotificationDeliveryIntegration:
    """Tests for notification delivery integration."""

    @pytest.mark.asyncio()
    async def test_successful_delivery(self, mock_bot):
        """Test successful notification delivery."""
        user_id = 123456789
        message = "Test notification"

        await mock_bot.send_message(chat_id=user_id, text=message)

        mock_bot.send_message.assert_called_once_with(chat_id=user_id, text=message)

    @pytest.mark.asyncio()
    async def test_delivery_with_keyboard(self, mock_bot):
        """Test notification delivery with inline keyboard."""
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup

        user_id = 123456789
        message = "Test notification"
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("View Details", callback_data="view_details")]
        ])

        await mock_bot.send_message(chat_id=user_id, text=message, reply_markup=keyboard)

        assert mock_bot.send_message.called

    @pytest.mark.asyncio()
    async def test_delivery_retry_on_failure(self, mock_bot):
        """Test notification delivery retry on failure."""
        # First attempt fails, second succeeds
        mock_bot.send_message.side_effect = [
            Exception("Network error"),
            MagicMock(message_id=123),
        ]

        user_id = 123456789
        message = "Test notification"

        # First attempt
        try:
            await mock_bot.send_message(chat_id=user_id, text=message)
        except Exception:
            pass

        # Retry
        result = await mock_bot.send_message(chat_id=user_id, text=message)
        assert result.message_id == 123


# ============================================================================
# NOTIFICATION STORAGE TESTS
# ============================================================================


class TestNotificationStorageIntegration:
    """Tests for notification storage integration."""

    @pytest.mark.asyncio()
    async def test_save_notification_history(self):
        """Test saving notification to history."""
        history = []

        notification = {
            "type": "price_drop",
            "item": "Test Item",
            "timestamp": datetime.now().isoformat(),
            "delivered": True,
        }

        history.append(notification)

        assert len(history) == 1
        assert history[0]["type"] == "price_drop"

    @pytest.mark.asyncio()
    async def test_get_recent_notifications(self):
        """Test getting recent notifications."""
        history = [
            {"timestamp": "2025-01-01T10:00:00", "type": "price_drop"},
            {"timestamp": "2025-01-01T11:00:00", "type": "arbitrage"},
            {"timestamp": "2025-01-01T12:00:00", "type": "good_deal"},
        ]

        # Get last 2
        recent = history[-2:]

        assert len(recent) == 2
        assert recent[0]["type"] == "arbitrage"
        assert recent[1]["type"] == "good_deal"

    @pytest.mark.asyncio()
    async def test_clear_old_notifications(self):
        """Test clearing old notifications."""
        history = [
            {"timestamp": "2024-01-01T10:00:00", "type": "old"},
            {"timestamp": "2025-01-01T10:00:00", "type": "new"},
        ]

        # Clear notifications older than cutoff
        cutoff_date = "2025-01-01"
        history = [n for n in history if n["timestamp"] >= cutoff_date]

        assert len(history) == 1
        assert history[0]["type"] == "new"


# ============================================================================
# COMPLETE NOTIFICATION WORKFLOW TESTS
# ============================================================================


class TestCompleteNotificationWorkflow:
    """Tests for complete notification workflow."""

    @pytest.mark.asyncio()
    async def test_price_alert_workflow(self, mock_bot, mock_user_settings):
        """Test complete price alert workflow."""
        # Step 1: Price change detected
        price_change = {
            "item_id": "item_123",
            "title": "AK-47 | Redline",
            "old_price": 20.00,
            "new_price": 15.00,
            "change_percent": -25.0,
        }

        # Step 2: Check user settings
        assert mock_user_settings["enabled"] is True
        assert mock_user_settings["notification_types"]["price_drop"] is True

        # Step 3: Format notification
        message = f"üìâ {price_change['title']}: ${price_change['old_price']} ‚Üí ${price_change['new_price']}"

        # Step 4: Send notification
        await mock_bot.send_message(chat_id=mock_user_settings["user_id"], text=message)

        assert mock_bot.send_message.called

    @pytest.mark.asyncio()
    async def test_arbitrage_alert_workflow(self, mock_bot, mock_user_settings):
        """Test complete arbitrage alert workflow."""
        # Step 1: Arbitrage opportunity found
        opportunity = {
            "item": "AWP | Dragon Lore",
            "buy_price": 1500.00,
            "sell_price": 1800.00,
            "profit": 300.00,
            "profit_percent": 20.0,
        }

        # Step 2: Check if profitable enough (> 10%)
        min_profit = 10.0
        assert opportunity["profit_percent"] > min_profit

        # Step 3: Format and send
        message = f"üí∞ –ê—Ä–±–∏—Ç—Ä–∞–∂: {opportunity['item']} +${opportunity['profit']:.2f}"
        await mock_bot.send_message(chat_id=mock_user_settings["user_id"], text=message)

        assert mock_bot.send_message.called

    @pytest.mark.asyncio()
    async def test_daily_digest_workflow(self, mock_bot, mock_user_settings):
        """Test daily digest notification workflow."""
        # Step 1: Collect daily statistics
        daily_stats = {
            "total_scans": 24,
            "opportunities_found": 15,
            "targets_created": 5,
            "successful_trades": 3,
            "total_profit": 250.00,
        }

        # Step 2: Format digest
        message = (
            f"üìä –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á—ë—Ç\n"
            f"üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–π: {daily_stats['total_scans']}\n"
            f"üí° –ù–∞–π–¥–µ–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {daily_stats['opportunities_found']}\n"
            f"üéØ –°–æ–∑–¥–∞–Ω–æ —Ç–∞—Ä–≥–µ—Ç–æ–≤: {daily_stats['targets_created']}\n"
            f"‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö —Å–¥–µ–ª–æ–∫: {daily_stats['successful_trades']}\n"
            f"üí∞ –û–±—â–∞—è –ø—Ä–∏–±—ã–ª—å: ${daily_stats['total_profit']:.2f}"
        )

        # Step 3: Send digest
        await mock_bot.send_message(chat_id=mock_user_settings["user_id"], text=message)

        assert mock_bot.send_message.called
        assert "üìä" in message
        assert f"${daily_stats['total_profit']:.2f}" in message
