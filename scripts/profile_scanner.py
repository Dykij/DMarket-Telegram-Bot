"""
Performance profiling script for ArbitrageScanner.

Profiles scanner performance and generates reports for optimization.
"""

import asyncio
import cProfile
from io import StringIO
import operator
from pathlib import Path
import pstats
import time


# Mock imports for profiling (replace with actual when running)
# from src.dmarket.arbitrage_scanner import ArbitrageScanner
# from src.dmarket.dmarket_api import DMarketAPI


async def profile_scanner_performance():
    """Profile scanner performance with different batch sizes."""
    print("üîç Starting Performance Profiling for ArbitrageScanner...")
    print("=" * 70)

    # TODO: Initialize scanner with real API client
    # api_client = DMarketAPI(public_key="test", secret_key="test")
    # scanner = ArbitrageScanner(api_client=api_client)

    batch_sizes = [10, 50, 100, 200]
    games = ["csgo", "dota2", "tf2", "rust"]
    levels = ["boost", "standard", "medium", "advanced", "pro"]

    results = []

    for game in games:
        for level in levels:
            print(f"\nüìä Profiling: {game.upper()} - {level.upper()}")
            print("-" * 70)

            # Start timing
            start_time = time.perf_counter()

            # TODO: Replace with actual scanner call
            # opportunities = await scanner.scan_level(level=level, game=game)
            await asyncio.sleep(0.1)  # Placeholder

            elapsed = time.perf_counter() - start_time

            result = {
                "game": game,
                "level": level,
                "elapsed_ms": round(elapsed * 1000, 2),
                # "opportunities_found": len(opportunities),
                "opportunities_found": 0,  # Placeholder
            }

            results.append(result)
            print(f"  ‚è±Ô∏è  Time: {result['elapsed_ms']}ms")
            print(f"  üí∞ Opportunities: {result['opportunities_found']}")

    # Generate summary
    print("\n" + "=" * 70)
    print("üìà PERFORMANCE SUMMARY")
    print("=" * 70)

    total_time = sum(r["elapsed_ms"] for r in results)
    avg_time = total_time / len(results)

    print(f"\n  Total Scans: {len(results)}")
    print(f"  Total Time: {round(total_time, 2)}ms")
    print(f"  Average Time: {round(avg_time, 2)}ms per scan")

    # Find slowest scans
    slowest = sorted(results, key=operator.itemgetter("elapsed_ms"), reverse=True)[:5]
    print("\n  üêå Slowest Scans:")
    for i, r in enumerate(slowest, 1):
        print(f"    {i}. {r['game']} - {r['level']}: {r['elapsed_ms']}ms")

    # Find fastest scans
    fastest = sorted(results, key=operator.itemgetter("elapsed_ms"))[:5]
    print("\n  üöÄ Fastest Scans:")
    for i, r in enumerate(fastest, 1):
        print(f"    {i}. {r['game']} - {r['level']}: {r['elapsed_ms']}ms")

    return results


async def profile_batch_processing():
    """Profile batch processing with different batch sizes."""
    print("\n" + "=" * 70)
    print("üì¶ BATCH PROCESSING PROFILING")
    print("=" * 70)

    batch_sizes = [10, 50, 100, 200, 500]
    total_items = 1000

    results = []

    for batch_size in batch_sizes:
        print(f"\n  Testing batch_size={batch_size}")

        start_time = time.perf_counter()

        # Simulate batch processing
        num_batches = (total_items + batch_size - 1) // batch_size
        for _ in range(num_batches):
            await asyncio.sleep(0.01)  # Simulate processing

        elapsed = time.perf_counter() - start_time

        result = {
            "batch_size": batch_size,
            "total_items": total_items,
            "num_batches": num_batches,
            "elapsed_ms": round(elapsed * 1000, 2),
            "items_per_second": round(total_items / elapsed, 2),
        }

        results.append(result)
        print(f"    ‚è±Ô∏è  Time: {result['elapsed_ms']}ms")
        print(f"    üöÄ Throughput: {result['items_per_second']} items/sec")

    # Find optimal batch size
    optimal = max(results, key=operator.itemgetter("items_per_second"))
    print("\n  ‚úÖ Optimal Batch Size:")
    print(f"    batch_size={optimal['batch_size']}")
    print(f"    Throughput: {optimal['items_per_second']} items/sec")

    return results


def profile_with_cprofile():
    """Profile using cProfile for detailed function-level stats."""
    print("\n" + "=" * 70)
    print("üî¨ DETAILED FUNCTION PROFILING (cProfile)")
    print("=" * 70)

    profiler = cProfile.Profile()
    profiler.enable()

    # Run the async profiling
    asyncio.run(profile_scanner_performance())

    profiler.disable()

    # Generate stats
    stats_stream = StringIO()
    stats = pstats.Stats(profiler, stream=stats_stream)
    stats.strip_dirs()
    stats.sort_stats("cumulative")

    print("\n  üìä Top 20 Functions by Cumulative Time:")
    stats.print_stats(20)

    # Save to file
    output_dir = Path("profiling_results")
    output_dir.mkdir(exist_ok=True)

    stats_file = output_dir / "scanner_profile.stats"
    stats.dump_stats(str(stats_file))
    print(f"\n  üíæ Profile saved to: {stats_file}")

    # Generate text report
    report_file = output_dir / "scanner_profile_report.txt"
    with open(report_file, "w", encoding="utf-8") as f:
        stats_obj = pstats.Stats(str(stats_file), stream=f)
        stats_obj.sort_stats("cumulative")
        stats_obj.print_stats()

    print(f"  üìÑ Text report saved to: {report_file}")


async def main():
    """Main profiling entry point."""
    print("\nüöÄ ArbitrageScanner Performance Profiling Tool")
    print("=" * 70)
    print("\nThis script profiles the performance of:")
    print("  1. Scanner across different games and levels")
    print("  2. Batch processing with various batch sizes")
    print("  3. Function-level profiling with cProfile")
    print()

    # Run profiling
    await profile_scanner_performance()
    await profile_batch_processing()

    # Detailed profiling (commented out - uncomment for deep analysis)
    # profile_with_cprofile()

    print("\n" + "=" * 70)
    print("‚úÖ Profiling Complete!")
    print("=" * 70)
    print("\nüí° Next Steps:")
    print("  1. Review results above")
    print("  2. Identify bottlenecks")
    print("  3. Apply optimizations (batch size, caching, etc.)")
    print("  4. Re-run profiling to measure improvements")
    print()


if __name__ == "__main__":
    asyncio.run(main())
