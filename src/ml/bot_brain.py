"""BotBrain - Central autonomous decision-making module.

This module implements the "brain" of the autonomous trading bot.
It coordinates all AI/ML modules to make trading decisions autonomously.

Architecture:
```
                    ┌─────────────────────┐
                    │      BotBrain       │
                    └──────────┬──────────┘
                               │
    ┌──────────────────────────┼──────────────────────────┐
    │                          │                          │
    ▼                          ▼                          ▼
┌────────────┐          ┌────────────┐          ┌────────────┐
│ Perception │          │  Decision  │          │ Execution  │
│   Module   │          │   Module   │          │   Module   │
└────────────┘          └────────────┘          └────────────┘
```

Usage:
    ```python
    from src.ml.bot_brain import BotBrain, AutonomyConfig

    # Initialize brain
    brain = BotBrain(
        dmarket_api=api_client,
        config=AutonomyConfig(
            autonomy_level=AutonomyLevel.SEMI_AUTO,
            max_trade_usd=50.0,
        ),
    )

    # Run one cycle
    results = await brain.run_cycle()

    # Or run continuously
    await brain.run_autonomous(scan_interval=60)
    ```

Created: January 2026
"""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import UTC, datetime, timedelta
from enum import StrEnum
import logging
from typing import TYPE_CHECKING, Any, Callable

from src.ml.ai_coordinator import (
    AICoordinator,
    AutonomyLevel,
    ItemAnalysis,
    SafetyLimits,
    TradeAction,
    TradeDecision,
)
from src.ml.discount_threshold_predictor import MarketCondition


if TYPE_CHECKING:
    from src.dmarket.dmarket_api import DMarketAPI


logger = logging.getLogger(__name__)


class BotState(StrEnum):
    """Current state of the bot brain."""

    IDLE = "idle"  # Not running
    SCANNING = "scanning"  # Scanning market
    ANALYZING = "analyzing"  # Analyzing opportunities
    DECIDING = "deciding"  # Making decisions
    EXECUTING = "executing"  # Executing trades
    LEARNING = "learning"  # Learning from outcomes
    PAUSED = "paused"  # Temporarily paused
    STOPPED = "stopped"  # Stopped (emergency or user request)


class AlertLevel(StrEnum):
    """Alert severity levels."""

    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class Alert:
    """An alert generated by the bot brain."""

    level: AlertLevel
    message: str
    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))
    data: dict[str, Any] = field(default_factory=dict)


@dataclass
class CycleResult:
    """Result of a single brain cycle."""

    cycle_number: int
    started_at: datetime
    completed_at: datetime

    # Scanning
    items_scanned: int = 0
    opportunities_found: int = 0

    # Decisions
    decisions_made: int = 0
    decisions_executed: int = 0
    decisions_skipped: int = 0
    decisions_pending: int = 0

    # Execution
    successful_trades: int = 0
    failed_trades: int = 0
    total_profit_estimate: float = 0.0

    # Errors
    errors: list[str] = field(default_factory=list)

    # Alerts
    alerts: list[Alert] = field(default_factory=list)

    @property
    def duration_seconds(self) -> float:
        """Get cycle duration in seconds."""
        return (self.completed_at - self.started_at).total_seconds()

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "cycle_number": self.cycle_number,
            "started_at": self.started_at.isoformat(),
            "completed_at": self.completed_at.isoformat(),
            "duration_seconds": round(self.duration_seconds, 2),
            "items_scanned": self.items_scanned,
            "opportunities_found": self.opportunities_found,
            "decisions_made": self.decisions_made,
            "decisions_executed": self.decisions_executed,
            "successful_trades": self.successful_trades,
            "total_profit_estimate": round(self.total_profit_estimate, 2),
            "errors": self.errors,
        }


@dataclass
class AutonomyConfig:
    """Configuration for autonomous operation."""

    # Autonomy level
    autonomy_level: AutonomyLevel = AutonomyLevel.MANUAL

    # Trade limits
    max_trade_usd: float = 50.0
    max_daily_volume_usd: float = 200.0
    max_trades_per_hour: int = 10
    max_position_percent: float = 30.0

    # Confidence requirements
    min_confidence_auto: float = 0.80
    min_confidence_semi_auto: float = 0.70

    # Risk limits
    max_consecutive_losses: int = 3
    loss_cooldown_minutes: int = 30
    daily_loss_limit_percent: float = 20.0

    # Scanning
    scan_interval_seconds: int = 60
    games_to_scan: list[str] = field(default_factory=lambda: ["csgo", "dota2"])
    max_items_per_scan: int = 100

    # Safety
    dry_run: bool = True
    require_confirmation_above_usd: float = 10.0

    # Notifications
    notify_on_trade: bool = True
    notify_on_error: bool = True
    notify_on_opportunity: bool = False


class BotBrain:
    """Central autonomous decision-making module.

    BotBrain coordinates all AI/ML components to:
    1. PERCEIVE: Scan market and collect data
    2. DECIDE: Analyze opportunities and make decisions
    3. EXECUTE: Execute trades (with confirmation if needed)
    4. LEARN: Learn from outcomes for continuous improvement

    Safety Features:
    - DRY_RUN mode by default
    - Trade limits (per-trade, daily, hourly)
    - Emergency stop on consecutive losses
    - User confirmation for large trades
    """

    def __init__(
        self,
        dmarket_api: DMarketAPI | None = None,
        config: AutonomyConfig | None = None,
        on_decision_callback: Callable[[TradeDecision], None] | None = None,
        on_alert_callback: Callable[[Alert], None] | None = None,
    ):
        """Initialize BotBrain.

        Args:
            dmarket_api: DMarket API client
            config: Autonomy configuration
            on_decision_callback: Callback for decisions requiring confirmation
            on_alert_callback: Callback for alerts
        """
        self.api = dmarket_api
        self.config = config or AutonomyConfig()

        # Callbacks
        self.on_decision = on_decision_callback
        self.on_alert = on_alert_callback

        # Initialize AI Coordinator
        safety_limits = SafetyLimits(
            max_single_trade_usd=self.config.max_trade_usd,
            max_daily_volume_usd=self.config.max_daily_volume_usd,
            max_position_percent=self.config.max_position_percent,
            min_confidence_auto=self.config.min_confidence_auto,
            max_trades_per_hour=self.config.max_trades_per_hour,
            loss_cooldown_minutes=self.config.loss_cooldown_minutes,
            dry_run=self.config.dry_run,
        )
        self.ai = AICoordinator(
            autonomy_level=self.config.autonomy_level,
            safety_limits=safety_limits,
        )

        # State
        self._state = BotState.IDLE
        self._cycle_count = 0
        self._is_running = False
        self._stop_requested = False

        # Statistics
        self._stats = {
            "total_cycles": 0,
            "total_items_scanned": 0,
            "total_opportunities": 0,
            "total_decisions": 0,
            "total_executions": 0,
            "successful_trades": 0,
            "failed_trades": 0,
            "total_profit": 0.0,
            "daily_volume": 0.0,
            "consecutive_losses": 0,
            "last_cycle_at": None,
            "started_at": None,
        }

        # Pending decisions (for confirmation)
        self._pending_decisions: list[TradeDecision] = []

        # Trade history for learning
        self._trade_history: list[dict[str, Any]] = []

        # Alerts
        self._alerts: list[Alert] = []
        self._max_alerts = 100

        # Cooldown tracking
        self._last_trade_at: datetime | None = None
        self._in_cooldown = False
        self._cooldown_until: datetime | None = None

        logger.info(
            "bot_brain_initialized",
            extra={
                "autonomy_level": self.config.autonomy_level.value,
                "dry_run": self.config.dry_run,
                "max_trade_usd": self.config.max_trade_usd,
            },
        )

    @property
    def state(self) -> BotState:
        """Get current state."""
        return self._state

    @property
    def is_running(self) -> bool:
        """Check if brain is running."""
        return self._is_running

    @property
    def pending_decisions(self) -> list[TradeDecision]:
        """Get pending decisions awaiting confirmation."""
        return self._pending_decisions.copy()

    def _set_state(self, state: BotState) -> None:
        """Update state with logging."""
        old_state = self._state
        self._state = state
        if old_state != state:
            logger.debug(
                "bot_brain_state_changed",
                extra={"old": old_state.value, "new": state.value},
            )

    def _add_alert(self, level: AlertLevel, message: str, data: dict[str, Any] | None = None) -> None:
        """Add an alert."""
        alert = Alert(level=level, message=message, data=data or {})
        self._alerts.append(alert)

        # Trim old alerts
        if len(self._alerts) > self._max_alerts:
            self._alerts = self._alerts[-self._max_alerts:]

        # Notify callback
        if self.on_alert:
            try:
                self.on_alert(alert)
            except Exception as e:
                logger.warning("alert_callback_failed", extra={"error": str(e)})

        # Log
        log_level = {
            AlertLevel.INFO: logging.INFO,
            AlertLevel.WARNING: logging.WARNING,
            AlertLevel.ERROR: logging.ERROR,
            AlertLevel.CRITICAL: logging.CRITICAL,
        }.get(level, logging.INFO)
        logger.log(log_level, message, extra={"alert_data": data})

    def _check_cooldown(self) -> bool:
        """Check if in cooldown period."""
        if not self._in_cooldown or not self._cooldown_until:
            return False

        if datetime.now(UTC) >= self._cooldown_until:
            self._in_cooldown = False
            self._cooldown_until = None
            self._add_alert(AlertLevel.INFO, "Cooldown period ended")
            return False

        return True

    def _check_daily_limits(self) -> bool:
        """Check if daily limits are exceeded."""
        if self._stats["daily_volume"] >= self.config.max_daily_volume_usd:
            self._add_alert(
                AlertLevel.WARNING,
                f"Daily volume limit reached: ${self._stats['daily_volume']:.2f}",
            )
            return False
        return True

    def _check_loss_limits(self) -> bool:
        """Check if loss limits are exceeded."""
        if self._stats["consecutive_losses"] >= self.config.max_consecutive_losses:
            # Enter cooldown
            self._in_cooldown = True
            self._cooldown_until = datetime.now(UTC) + timedelta(
                minutes=self.config.loss_cooldown_minutes
            )
            self._stats["consecutive_losses"] = 0

            self._add_alert(
                AlertLevel.WARNING,
                f"Consecutive loss limit reached. Entering cooldown for "
                f"{self.config.loss_cooldown_minutes} minutes.",
            )
            return False
        return True

    async def _scan_market(self) -> list[dict[str, Any]]:
        """Scan market for items."""
        items = []

        if not self.api:
            logger.warning("No API client configured, skipping scan")
            return items

        try:
            for game in self.config.games_to_scan:
                # Get market items
                response = await self.api.get_market_items(
                    game_id=game,
                    limit=self.config.max_items_per_scan,
                )

                game_items = response.get("objects", [])
                for item in game_items:
                    item["gameId"] = game  # Ensure game ID is set
                items.extend(game_items)

                logger.debug(
                    "market_scan_game_complete",
                    extra={"game": game, "items_found": len(game_items)},
                )

        except Exception as e:
            self._add_alert(
                AlertLevel.ERROR,
                f"Market scan failed: {e}",
                {"error": str(e)},
            )
            logger.exception("market_scan_failed")

        return items

    async def _analyze_opportunities(
        self, items: list[dict[str, Any]]
    ) -> list[TradeDecision]:
        """Analyze items and make decisions."""
        decisions = await self.ai.scan_and_decide(
            items=items,
            max_decisions=20,
        )
        return decisions

    def _filter_decisions(
        self, decisions: list[TradeDecision]
    ) -> tuple[list[TradeDecision], list[TradeDecision]]:
        """Filter decisions into auto-execute and pending confirmation.

        Returns:
            Tuple of (auto_execute, pending_confirmation) lists
        """
        auto_execute = []
        pending = []

        for decision in decisions:
            if decision.action in {TradeAction.HOLD, TradeAction.SKIP}:
                continue

            # Check if auto-execute is allowed
            can_auto = self._can_auto_execute(decision)

            if can_auto:
                auto_execute.append(decision)
            else:
                decision.requires_confirmation = True
                pending.append(decision)

        return auto_execute, pending

    def _can_auto_execute(self, decision: TradeDecision) -> bool:
        """Check if decision can be auto-executed."""
        # DRY_RUN mode - never auto-execute real trades
        if self.config.dry_run:
            # In DRY_RUN, we "execute" but it's simulated
            return decision.confidence >= self.config.min_confidence_auto

        # Check autonomy level
        if self.config.autonomy_level == AutonomyLevel.MANUAL:
            return False

        if self.config.autonomy_level == AutonomyLevel.SEMI_AUTO:
            return (
                decision.confidence >= self.config.min_confidence_semi_auto
                and decision.current_price <= self.config.require_confirmation_above_usd
            )

        # AUTO mode
        return (
            decision.confidence >= self.config.min_confidence_auto
            and decision.current_price <= self.config.max_trade_usd
        )

    async def _execute_decision(self, decision: TradeDecision) -> bool:
        """Execute a single trading decision.

        Returns:
            True if successful, False otherwise
        """
        if self.config.dry_run:
            # Simulate execution
            logger.info(
                "dry_run_execution",
                extra={
                    "action": decision.action.value,
                    "item": decision.item_name,
                    "price": decision.current_price,
                },
            )
            decision.executed = True
            decision.execution_result = {
                "success": True,
                "dry_run": True,
                "message": "DRY_RUN: Trade simulated",
            }
            return True

        if not self.api:
            logger.error("No API client for execution")
            return False

        try:
            if decision.action == TradeAction.BUY:
                result = await self.api.buy_item(
                    item_id=decision.item_id,
                    price=decision.current_price,
                )
            elif decision.action == TradeAction.CREATE_TARGET:
                result = await self.api.create_target(
                    title=decision.item_name,
                    price=int(decision.current_price * 100),  # Convert to cents
                    amount=1,
                )
            else:
                logger.warning(f"Unsupported action: {decision.action}")
                return False

            decision.executed = True
            decision.execution_result = result
            return result.get("success", True)

        except Exception as e:
            logger.exception("execution_failed", error=str(e))
            decision.execution_result = {"success": False, "error": str(e)}
            return False

    async def _learn_from_outcomes(self, decisions: list[TradeDecision]) -> None:
        """Learn from executed decisions."""
        for decision in decisions:
            if not decision.executed:
                continue

            # Add to trade history
            self._trade_history.append({
                "decision": decision.to_dict(),
                "timestamp": datetime.now(UTC).isoformat(),
            })

            # Update AI coordinator for continuous learning
            # (In real scenario, we'd track actual P&L later)
            estimated_profit = decision.expected_profit
            was_profitable = estimated_profit > 0

            self.ai.add_trade_outcome(
                decision=decision,
                actual_profit=estimated_profit,
                was_profitable=was_profitable,
            )

        # Keep only last 1000 trades
        if len(self._trade_history) > 1000:
            self._trade_history = self._trade_history[-1000:]

    async def run_cycle(self) -> CycleResult:
        """Run one complete brain cycle.

        A cycle consists of:
        1. SCAN: Scan market for items
        2. ANALYZE: Analyze and score opportunities
        3. DECIDE: Make trading decisions
        4. EXECUTE: Execute approved decisions
        5. LEARN: Learn from outcomes

        Returns:
            CycleResult with cycle statistics
        """
        self._cycle_count += 1
        started_at = datetime.now(UTC)

        result = CycleResult(
            cycle_number=self._cycle_count,
            started_at=started_at,
            completed_at=started_at,  # Will be updated
        )

        try:
            # Pre-cycle checks
            if self._check_cooldown():
                result.errors.append("In cooldown period")
                result.completed_at = datetime.now(UTC)
                return result

            if not self._check_daily_limits():
                result.errors.append("Daily limit reached")
                result.completed_at = datetime.now(UTC)
                return result

            if not self._check_loss_limits():
                result.errors.append("Loss limit triggered")
                result.completed_at = datetime.now(UTC)
                return result

            # 1. SCAN
            self._set_state(BotState.SCANNING)
            items = await self._scan_market()
            result.items_scanned = len(items)
            self._stats["total_items_scanned"] += len(items)

            if not items:
                logger.info("No items found in scan")
                result.completed_at = datetime.now(UTC)
                return result

            # 2. ANALYZE & DECIDE
            self._set_state(BotState.ANALYZING)
            decisions = await self._analyze_opportunities(items)
            result.opportunities_found = len(decisions)
            self._stats["total_opportunities"] += len(decisions)

            # 3. FILTER
            self._set_state(BotState.DECIDING)
            auto_execute, pending = self._filter_decisions(decisions)
            result.decisions_made = len(auto_execute) + len(pending)
            result.decisions_pending = len(pending)
            self._stats["total_decisions"] += result.decisions_made

            # Add pending to queue
            self._pending_decisions.extend(pending)
            for decision in pending:
                if self.on_decision:
                    try:
                        self.on_decision(decision)
                    except Exception as e:
                        logger.warning("decision_callback_failed", extra={"error": str(e)})

            # 4. EXECUTE
            self._set_state(BotState.EXECUTING)
            for decision in auto_execute:
                success = await self._execute_decision(decision)
                if success:
                    result.successful_trades += 1
                    result.total_profit_estimate += decision.expected_profit
                    self._stats["successful_trades"] += 1
                    self._stats["total_profit"] += decision.expected_profit
                    self._stats["consecutive_losses"] = 0
                else:
                    result.failed_trades += 1
                    self._stats["failed_trades"] += 1
                    self._stats["consecutive_losses"] += 1

            result.decisions_executed = len(auto_execute)
            self._stats["total_executions"] += len(auto_execute)
            self._stats["daily_volume"] += sum(d.current_price for d in auto_execute)

            # 5. LEARN
            self._set_state(BotState.LEARNING)
            await self._learn_from_outcomes(auto_execute)

        except Exception as e:
            result.errors.append(str(e))
            self._add_alert(AlertLevel.ERROR, f"Cycle failed: {e}")
            logger.exception("cycle_failed")

        finally:
            result.completed_at = datetime.now(UTC)
            self._stats["total_cycles"] += 1
            self._stats["last_cycle_at"] = result.completed_at.isoformat()
            self._set_state(BotState.IDLE)

        logger.info(
            "cycle_completed",
            extra={
                "cycle": self._cycle_count,
                "duration_s": result.duration_seconds,
                "scanned": result.items_scanned,
                "opportunities": result.opportunities_found,
                "executed": result.decisions_executed,
            },
        )

        return result

    async def run_autonomous(
        self,
        scan_interval: int | None = None,
        max_cycles: int | None = None,
    ) -> None:
        """Run autonomous cycle continuously.

        Args:
            scan_interval: Seconds between scans (default: from config)
            max_cycles: Maximum cycles to run (None = infinite)
        """
        interval = scan_interval or self.config.scan_interval_seconds

        self._is_running = True
        self._stop_requested = False
        self._stats["started_at"] = datetime.now(UTC).isoformat()

        logger.info(
            "autonomous_mode_started",
            extra={
                "interval": interval,
                "max_cycles": max_cycles,
                "autonomy_level": self.config.autonomy_level.value,
            },
        )

        self._add_alert(
            AlertLevel.INFO,
            f"Autonomous mode started (interval: {interval}s)",
        )

        cycles_run = 0
        try:
            while not self._stop_requested:
                if max_cycles and cycles_run >= max_cycles:
                    break

                result = await self.run_cycle()
                cycles_run += 1

                # Alert on significant events
                if result.successful_trades > 0:
                    self._add_alert(
                        AlertLevel.INFO,
                        f"Cycle {result.cycle_number}: {result.successful_trades} trades, "
                        f"${result.total_profit_estimate:.2f} profit",
                    )

                # Wait for next cycle
                if not self._stop_requested:
                    await asyncio.sleep(interval)

        except asyncio.CancelledError:
            logger.info("Autonomous mode cancelled")
        finally:
            self._is_running = False
            self._set_state(BotState.STOPPED)
            self._add_alert(AlertLevel.INFO, "Autonomous mode stopped")

    def stop(self) -> None:
        """Request stop of autonomous operation."""
        self._stop_requested = True
        self._add_alert(AlertLevel.INFO, "Stop requested")

    def pause(self) -> None:
        """Pause autonomous operation."""
        self._set_state(BotState.PAUSED)
        self._add_alert(AlertLevel.INFO, "Bot paused")

    def resume(self) -> None:
        """Resume autonomous operation."""
        if self._state == BotState.PAUSED:
            self._set_state(BotState.IDLE)
            self._add_alert(AlertLevel.INFO, "Bot resumed")

    def emergency_stop(self, reason: str = "Manual emergency stop") -> None:
        """Emergency stop with immediate halt."""
        self._stop_requested = True
        self._is_running = False
        self._set_state(BotState.STOPPED)
        self._add_alert(AlertLevel.CRITICAL, f"EMERGENCY STOP: {reason}")
        logger.critical("emergency_stop", extra={"reason": reason})

    async def confirm_decision(self, decision_index: int) -> bool:
        """Confirm and execute a pending decision.

        Args:
            decision_index: Index in pending_decisions list

        Returns:
            True if execution successful
        """
        if decision_index < 0 or decision_index >= len(self._pending_decisions):
            return False

        decision = self._pending_decisions.pop(decision_index)
        success = await self._execute_decision(decision)

        if success:
            self._stats["successful_trades"] += 1
            self._stats["total_profit"] += decision.expected_profit
            await self._learn_from_outcomes([decision])
        else:
            self._stats["failed_trades"] += 1

        return success

    def reject_decision(self, decision_index: int) -> bool:
        """Reject a pending decision.

        Args:
            decision_index: Index in pending_decisions list

        Returns:
            True if rejection successful
        """
        if decision_index < 0 or decision_index >= len(self._pending_decisions):
            return False

        self._pending_decisions.pop(decision_index)
        return True

    def clear_pending_decisions(self) -> int:
        """Clear all pending decisions.

        Returns:
            Number of decisions cleared
        """
        count = len(self._pending_decisions)
        self._pending_decisions.clear()
        return count

    def get_statistics(self) -> dict[str, Any]:
        """Get bot brain statistics."""
        return {
            **self._stats,
            "state": self._state.value,
            "is_running": self._is_running,
            "pending_decisions": len(self._pending_decisions),
            "in_cooldown": self._in_cooldown,
            "cooldown_until": self._cooldown_until.isoformat() if self._cooldown_until else None,
            "config": {
                "autonomy_level": self.config.autonomy_level.value,
                "dry_run": self.config.dry_run,
                "max_trade_usd": self.config.max_trade_usd,
            },
        }

    def get_alerts(self, limit: int = 20) -> list[Alert]:
        """Get recent alerts.

        Args:
            limit: Maximum alerts to return

        Returns:
            List of recent alerts
        """
        return self._alerts[-limit:]

    def reset_daily_stats(self) -> None:
        """Reset daily statistics (call at midnight)."""
        self._stats["daily_volume"] = 0.0
        self._add_alert(AlertLevel.INFO, "Daily statistics reset")


# Factory function
def create_bot_brain(
    dmarket_api: DMarketAPI | None = None,
    autonomy_level: AutonomyLevel = AutonomyLevel.MANUAL,
    dry_run: bool = True,
    max_trade_usd: float = 50.0,
) -> BotBrain:
    """Create a BotBrain instance with common configuration.

    Args:
        dmarket_api: DMarket API client
        autonomy_level: Autonomy level
        dry_run: Enable dry run mode
        max_trade_usd: Maximum trade amount

    Returns:
        Configured BotBrain instance
    """
    config = AutonomyConfig(
        autonomy_level=autonomy_level,
        dry_run=dry_run,
        max_trade_usd=max_trade_usd,
    )
    return BotBrain(dmarket_api=dmarket_api, config=config)
