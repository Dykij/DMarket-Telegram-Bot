name: CI Pipeline (Simplified)

# –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π CI pipeline - –æ—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.11"  # Updated to match project requirements
  CACHE_VERSION: "v2"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Main CI job for continuous integration
  ci:
    name: Continuous Integration
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      checks: write
      pull-requests: write
    
    steps:
      # Step 1: Checkout code with full history for better analysis
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better blame analysis

      # Step 2: Set up Python 3.10 with caching
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'

      # Step 3: Cache pip dependencies for faster builds
      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            .venv
          key: ${{ env.CACHE_VERSION }}-${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-python-

      # Step 4: Install dependencies with error handling
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          # Install test dependencies explicitly
          pip install pytest pytest-asyncio pytest-cov pytest-xdist pytest-mock
          # Install linting tools
          pip install flake8 black ruff mypy bandit safety
          # Install coverage tools
          pip install coverage codecov
          # Install main dependencies
          pip install -r requirements.txt
          # Verify installations
          python -c "import pytest; import ruff; import mypy; print('All dependencies installed successfully')"

      # Step 5: Code style and linting with multiple tools
      - name: Run code linting (Flake8)
        run: |
          flake8 src tests scripts --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src tests scripts --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics

      - name: Run code formatting check (Black)
        run: |
          black --check --diff src tests scripts

      - name: Run modern linting (Ruff)
        run: |
          ruff check src tests scripts --output-format=github
          ruff format --check src tests scripts

      # Step 6: Type checking with MyPy
      - name: Run type checking (MyPy)
        run: |
          mypy src --install-types --non-interactive --ignore-missing-imports

      # Step 7: Security scanning
      - name: Run security scan (Bandit)
        run: |
          bandit -r src/ -f json -o bandit-report.json
        continue-on-error: true

      - name: Run dependency vulnerability check (Safety)
        run: |
          safety check --json --output safety-report.json
        continue-on-error: true

      # Step 8: Build check using Makefile if available
      - name: Run build check
        run: |
          if [ -f Makefile ]; then
            make lint || echo "Makefile lint target not found, skipping"
            make check-types || echo "Makefile type-check target not found, skipping"
          fi

      # Step 9: Test bot-specific artifacts
      - name: Validate bot configuration
        run: |
          python -c "
          import sys
          sys.path.append('src')
          try:
              from utils.config import Config
              print('‚úì Configuration module imports successfully')
          except ImportError as e:
              print(f'‚úó Configuration import failed: {e}')
              sys.exit(1)
          "

      # Step 10: Create test environment
      - name: Create test environment file
        run: |
          echo "TELEGRAM_BOT_TOKEN=test_token_${{ github.run_id }}" > .env
          echo "DMARKET_PUBLIC_KEY=test_public_key" >> .env
          echo "DMARKET_SECRET_KEY=test_secret_key" >> .env
          echo "DATABASE_URL=sqlite:///test.db" >> .env
          echo "TESTING=true" >> .env
          echo "DEBUG=false" >> .env
          echo "LOG_LEVEL=INFO" >> .env

      # Step 11: Run comprehensive tests with coverage
      - name: Run unit tests with coverage
        run: |
          # Run tests with detailed output and coverage
          pytest tests/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-fail-under=80 \
            --maxfail=5 \
            --tb=short \
            -v \
            --durations=10
        env:
          PYTHONPATH: ${{ github.workspace }}/src

      # Step 12: Upload test artifacts
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports-${{ github.run_id }}
          path: |
            coverage.xml
            htmlcov/
            .coverage

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.run_id }}
          path: |
            bandit-report.json
            safety-report.json

      # Step 13: Coverage enforcement (fail if < 80%)
      - name: Check coverage threshold
        run: |
          coverage report --fail-under=80
          echo "‚úì Coverage meets minimum threshold of 80%"

      # Step 14: Integration test (if bot can be started)
      - name: Test bot startup
        run: |
          timeout 30s python -m src.main --help || echo "Bot help command completed"
        continue-on-error: true

      # Step 15: Upload coverage to external service
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          verbose: true

  # Multi-version testing matrix
  test-matrix:
    name: Test Python ${{ matrix.python-version }}
    runs-on: ubuntu-latest
    needs: ci
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    permissions:
      contents: read
    
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]
        include:
          - python-version: "3.10"
            primary: true
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
          POSTGRES_USER: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          --tmpfs /var/lib/postgresql/data:rw,noexec,nosuid,size=1024m
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            .venv
          key: ${{ env.CACHE_VERSION }}-${{ runner.os }}-python-${{ matrix.python-version }}-${{ hashFiles('requirements.txt') }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install pytest pytest-asyncio pytest-cov pytest-xdist
          pip install -r requirements.txt

      - name: Create test environment
        run: |
          echo "TELEGRAM_BOT_TOKEN=test_token_${{ github.run_id }}" > .env
          echo "DMARKET_PUBLIC_KEY=test_key" >> .env
          echo "DMARKET_SECRET_KEY=test_secret" >> .env
          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db" >> .env
          echo "REDIS_URL=redis://localhost:6379/0" >> .env
          echo "TESTING=true" >> .env

      - name: Wait for services
        run: |
          # Wait for PostgreSQL
          until pg_isready -h localhost -p 5432; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          # Wait for Redis
          until redis-cli -h localhost -p 6379 ping; do
            echo "Waiting for Redis..."
            sleep 2
          done

      - name: Run tests for Python ${{ matrix.python-version }}
        run: |
          pytest tests/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=term \
            -n auto \
            --maxfail=10 \
            --tb=short \
            -v
        env:
          PYTHONPATH: ${{ github.workspace }}/src

      - name: Upload coverage for Python ${{ matrix.python-version }}
        if: matrix.primary
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./coverage.xml
          flags: python-${{ matrix.python-version }}
          fail_ci_if_error: false

  # Enhanced security scanning
  security:
    name: Security & Vulnerability Scan
    runs-on: ubuntu-latest
    needs: ci
    permissions:
      contents: read
      security-events: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit[toml] safety semgrep pip-audit

      - name: Run Bandit security scan
        run: |
          bandit -r src/ -f json -o bandit-report.json
          bandit -r src/ -f sarif -o bandit.sarif
        continue-on-error: true

      - name: Run Safety vulnerability check
        run: |
          safety check --json --output safety-report.json --continue-on-error
        continue-on-error: true

      - name: Run pip-audit for dependency vulnerabilities
        run: |
          pip-audit --format=json --output=pip-audit-report.json --continue-on-vuln
        continue-on-error: true

      - name: Run Semgrep static analysis
        uses: returntocorp/semgrep-action@v1
        with:
          config: auto
          generateSarif: "1"
        continue-on-error: true

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: bandit.sarif
        continue-on-error: true

      - name: Upload security artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.run_id }}
          path: |
            bandit-report.json
            safety-report.json
            pip-audit-report.json
            .semgrep.sarif

  # Build and containerization
  build:
    name: Build & Docker Image
    runs-on: ubuntu-latest
    needs: [ci, security]
    if: github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'build')
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Test if the application can be packaged
      - name: Test application packaging
        run: |
          python -m pip install --upgrade pip build
          python -m build --sdist --wheel
          echo "‚úì Application can be packaged successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Docker Hub
        if: github.event_name != 'pull_request' && secrets.DOCKER_USERNAME
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository }}
            ${{ secrets.DOCKER_USERNAME && 'dmarket/telegram-bot' || '' }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            PYTHON_VERSION=${{ env.PYTHON_VERSION }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}

  # Deployment job (only on main branch)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [ci, test-matrix, security, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip deploy]')
    environment: 
      name: production
      url: ${{ steps.deploy.outputs.url }}
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Deploy to production server'
            });
            return deployment.data.id;

      - name: Deploy to production server
        id: deploy
        run: |
          echo "üöÄ Starting deployment..."
          
          # Example deployment commands (customize for your setup)
          if [[ -n "${{ secrets.DEPLOY_HOST }}" ]]; then
            echo "Deploying to remote server..."
            # Install SSH key
            mkdir -p ~/.ssh
            echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan -H "${{ secrets.DEPLOY_HOST }}" >> ~/.ssh/known_hosts
            
            # Deploy via SSH
            ssh "${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}" << 'EOF'
            cd /opt/dmarket-bot
            git pull origin main
            docker-compose pull
            docker-compose up -d --no-deps bot
            docker system prune -f
            EOF
            
            echo "url=https://${{ secrets.DEPLOY_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  No deployment configuration found (DEPLOY_HOST secret not set)"
            echo "This would deploy to production server if configured"
            echo "url=https://your-bot-domain.com" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Deployment completed"

      - name: Update deployment status (success)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              environment_url: '${{ steps.deploy.outputs.url }}',
              description: 'Deployment completed successfully'
            });

      - name: Update deployment status (failure)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Deployment failed'
            });

  # Notification and reporting
  notify:
    name: Notify & Report
    runs-on: ubuntu-latest
    needs: [ci, test-matrix, security, build, deploy]
    if: always()
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate summary report
        run: |
          echo "# ü§ñ CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Job Status Overview" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| CI | ${{ needs.ci.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tests | ${{ needs.test-matrix.result == 'success' && '‚úÖ Passed' || needs.test-matrix.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security | ${{ needs.security.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result == 'success' && '‚úÖ Passed' || needs.build.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result == 'success' && '‚úÖ Deployed' || needs.deploy.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìù Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Python Version**: ${{ env.PYTHON_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify on Slack (Success)
        if: success() && secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: success
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          text: "‚úÖ DMarket Bot CI/CD pipeline completed successfully!"

      - name: Notify on Slack (Failure)
        if: failure() && secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          text: "‚ùå DMarket Bot CI/CD pipeline failed!"

      - name: Create issue on failure
        if: failure() && github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üö® CI/CD Pipeline Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## Pipeline Failure Report
            
            **Commit**: ${context.sha}
            **Branch**: ${context.ref}
            **Workflow**: ${context.workflow}
            **Run ID**: ${context.runId}
            
            ### Failed Jobs
            ${JSON.stringify(context.payload, null, 2)}
            
            ### Action Required
            - [ ] Review failed job logs
            - [ ] Fix identified issues
            - [ ] Rerun pipeline
            
            **View Details**: ${context.payload.repository.html_url}/actions/runs/${context.runId}
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'ci/cd', 'automated']
            });

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ job.status }}' === 'success';
            const emoji = success ? '‚úÖ' : '‚ùå';
            const status = success ? 'passed' : 'failed';
            
            const body = `
            ## ${emoji} CI/CD Pipeline ${status}
            
            **Status Summary:**
            - CI: ${{ needs.ci.result == 'success' && '‚úÖ' || '‚ùå' }}
            - Tests: ${{ needs.test-matrix.result == 'success' && '‚úÖ' || needs.test-matrix.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }}
            - Security: ${{ needs.security.result == 'success' && '‚úÖ' || '‚ùå' }}
            - Build: ${{ needs.build.result == 'success' && '‚úÖ' || needs.build.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }}
            
            View details: [Workflow Run](${context.payload.repository.html_url}/actions/runs/${context.runId})
            `;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });